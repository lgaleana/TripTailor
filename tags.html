<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
		<title>Autocomplete Tags</title>

		<link href="css/general.css" rel="stylesheet">

		<style>
			body {
				background: #AAA;
			}
			.search-div {
				border: 1px solid black;
				background-color: white;
				display: table;
				width: 100%;
				border-spacing: 5px;
			}
			input {
				border: none;
				padding: 0;
				font-size: 20px;
				outline: none;
				width: 100%;
			}
			.inline {
				display: table-cell;
				width: 100%;
			}
			.tag {
				display: table-cell;
				color: white;
				background: orange;
				border-radius: 4px;
				padding: 10px;
			}
		</style>

	</head>
	<body>

		<script type="text/jsx">

			var HOSTELSURL = "http://localhost:8080/v2_react/hostels/";
			var AUTOCOMPLETECITYURL = HOSTELSURL + "hints/hostels/";
			var TIMEOUT = 300;

			var AutoCompleteSearch = React.createClass({
				getInitialState: function() {
					return {cityValue: '', tags: []};
				},
				updateCityValue: function(value) {
					this.setState({cityValue: value});
				},
				addTag: function(value) {
					var tags = this.state.tags.slice(0, this.state.tags.length);
					tags.push(value);
					this.setState({tags: tags});
				},
				render: function() {
					var tags = $.map(this.state.tags, function(value, i) {
						console.log(value);
						return (
							<div className="tag">{value}</div>
						);
					});

					return (
						<div className="search-div">
							{tags}
							<TripTailorAutoCompleteInput url={AUTOCOMPLETECITYURL} value={this.state.cityValue} className="" placeholder="Pick a city" updateValue={this.updateCityValue} addTag={this.addTag} />
						</div>
					);
				}
			});

			var TripTailorAutoCompleteInput = React.createClass({
				getInitialState: function() {
					return {hints: {}, selectedCategory: 0, selectedItem: -2};
				},
				onValueChange: function() {
					this.props.updateValue(React.findDOMNode(this.refs.query).value);
				},
				getHints: function() {
					var value = this.props.value;
					setTimeout(function() {
						if(value != '' && value == this.props.value) {
							$.ajax({
								url: this.props.url + this.props.value.trim().replace(/ /g, "-"),
								dataType: 'json',
								type: 'GET',
								success: function(data) {
									this.setState({hints: data, selectedCategory: 0, selectedItem: -1});
								}.bind(this),
								error: function(xhr, status, err) {
									console.error(this.props.url, status, err.toString());
								}.bind(this)
							});
						}
					}.bind(this), TIMEOUT);
				},
				handleKeyUp: function(e) {
					if(e.keyCode == 27) {
						this.setState({selectedItem: -2});
					}
					else if(this.props.value == '') {
						this.setState({selectedItem: -2});
					}
					else if(e.keyCode == 13) {
						this.props.addTag(this.state.hints[Object.keys(this.state.hints)[this.state.selectedCategory]][this.state.selectedItem]);
						this.setState({selectedItem: -2});
					}
					else if((e.keyCode > 31 && e.keyCode != 38 && e.keyCode != 40) || e.keyCode == 8) {
						this.getHints();
					}
				},
				handleKeyDown: function(e) {
					var keys = Object.keys(this.state.hints);
					var values = React.findDOMNode(this.refs.query).value.split(" ");
					var inputValue = values.length > 1 ? values[0] : "";
					for(var i = 1; i < values.length - 1; i++)
						inputValue += " " + values[i];

					if(e.keyCode == 9) {
						e.preventDefault();
						this.props.addTag(this.state.hints[Object.keys(this.state.hints)[this.state.selectedCategory]][this.state.selectedItem]);
						this.setState({selectedItem: -2});
					}
					else if(e.keyCode == 38 && this.state.selectedItem > -2) {
						e.preventDefault();
						if(this.state.selectedCategory > 0 || this.state.selectedItem > 0) {
							if(this.state.selectedItem == 0) {
								var newSelectedItem = this.state.hints[keys[this.state.selectedCategory - 1]].length - 1;
								if(this.props.append && this.state.selected - 1 == 0)
									this.props.updateValue(inputValue + " " + this.state.hints[keys[this.state.selectedCategory - 1]][newSelectedItem]);
								else
									this.props.updateValue(this.state.hints[keys[this.state.selectedCategory - 1]][newSelectedItem]);
								this.setState({selectedCategory: this.state.selectedCategory - 1, selectedItem: newSelectedItem});
							}
							else {
								if(this.props.append && this.state.selectedCategory == 0)
									this.props.updateValue(inputValue + " " + this.state.hints[keys[this.state.selectedCategory]][this.state.selectedItem - 1]);
								else
									this.props.updateValue(this.state.hints[keys[this.state.selectedCategory]][this.state.selectedItem - 1]);
								this.setState({selectedItem: this.state.selectedItem - 1});
							}
						}
					}
					else if(e.keyCode == 40 && this.state.selectedItem > -2) {
						e.preventDefault();
						if(this.state.selectedCategory < keys.length - 1 || this.state.selectedItem < this.state.hints[keys[this.state.selectedCategory]].length - 1) {
							if(this.state.selectedItem == this.state.hints[keys[this.state.selectedCategory]].length - 1) {
								if(this.props.append && this.state.selectedCategory == 0)
									this.props.updateValue(inputValue + " " + this.state.hints[keys[this.state.selectedCategory + 1]][0]);
								else
									this.props.updateValue(this.state.hints[keys[this.state.selectedCategory + 1]][0]);
								this.setState({selectedCategory: this.state.selectedCategory + 1, selectedItem: 0});
							}
							else {
								if(this.props.append && this.state.selectedCategory == 0)
									this.props.updateValue(inputValue + " " + this.state.hints[keys[this.state.selectedCategory]][this.state.selectedItem + 1]);
								else
									this.props.updateValue(this.state.hints[keys[this.state.selectedCategory]][this.state.selectedItem + 1]);
								this.setState({selectedItem: this.state.selectedItem + 1});
							}
						}
					}
				},
				handleBlur: function() {
					this.props.addTag(this.state.hints[Object.keys(this.state.hints)[this.state.selectedCategory]][this.state.selectedItem]);
					this.setState({selectedItem: -2});
				},
				elementClick: function(value, isAppendable) {
					if(this.props.append && isAppendable)
						this.props.updateValue(React.findDOMNode(this.refs.query).value + " " + value);
					else
						this.props.updateValue(value);
					this.props.addTag(value);
					this.setState({selectedItem: -2});
				},
				capitalizeFirst: function(s) {
					return s.charAt(0).toUpperCase() + s.substring(1);
				},
				clickOnAutoComplete: function(e) {
					e.preventDefault();
				},
				scrollToRow: function(row) {
					var modifier = this.state.selectedItem == 0 || this.state.selectedItem == this.state.hints[Object.keys(this.state.hints)[this.state.selectedCategory]].length - 1 ? 76 : 38;
					var autocomplete = React.findDOMNode(this.refs.autocomplete);
					var rowPos = $(row).position();
					var autocompletePos = $(autocomplete).position();
					if((rowPos.top + $(row).height()) > (autocompletePos.top + $(autocomplete).height()))
						$(autocomplete).scrollTop($(autocomplete).scrollTop() + modifier);
					else if(rowPos.top < autocompletePos.top)
						$(autocomplete).scrollTop($(autocomplete).scrollTop() - modifier);
				},
				render: function() {
					var rows = [];
					var category = 0;
					$.each(this.state.hints, function(key, value) {
						if(value.length > 0) {
							rows.push(<p className="title">{this.capitalizeFirst(key)}</p>);
							$.each(value, function(i, value) {
								rows.push(<TripTailorAutoCompleteRow value={value} category={category} index={i} selectedCategory={this.state.selectedCategory} selectedItem={this.state.selectedItem} elementClick={this.elementClick} scrollToThis={this.scrollToRow} />);
							}.bind(this));
							category++;
						}
					}.bind(this));

					return (
						<div className="inline">
							<input ref="query" type="text" className={this.props.className} placeholder={this.props.placeholder} autoComplete="off" value={this.props.value} onChange={this.onValueChange} onKeyUp={this.handleKeyUp} onKeyDown={this.handleKeyDown} onBlur={this.handleBlur} />
							{this.state.selectedItem >= -1 && rows.length > 0 ? <div className="relative">
								<div ref="autocomplete" className="autocomplete" onMouseDown={this.clickOnAutoComplete}>
									{rows}
								</div>
							</div> : ''}
						</div>
					);
				}
			});

			var TripTailorAutoCompleteRow = React.createClass({
				handleClick: function() {
					this.props.elementClick(this.props.value, this.category == 0);
				},
				componentDidUpdate: function() {
					if(this.props.selectedCategory == this.props.category && this.props.selectedItem == this.props.index)
						this.props.scrollToThis(React.findDOMNode(this));
				},
				render: function() {
					return (
						<p className={this.props.selectedCategory == this.props.category && this.props.selectedItem == this.props.index ? "autocomplete-element selected" : "autocomplete-element"} onMouseDown={this.handleClick}>{this.props.value}</p>
					);
				}
			});

			React.render(<AutoCompleteSearch />, document.body);

    </script>

    <script src="https://fb.me/react-0.13.3.js"></script>
    <script src="https://fb.me/JSXTransformer-0.13.3.js"></script>
    <script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
		<script src="js/bootstrap.min.js"></script>
		<script src="js/index.js"></script>
	</body>
</html>
